{
  "profile": {
    "name": "Kartik Jayram Jondhalekar",
    "title": "Full-Stack Software Engineer",
    "location": "Boston, MA",
    "tagline": "Building responsive UIs and scalable backend systems that users feel.",
    "bio": "Full-Stack Engineer with experience building enterprise systems at Chevron and modern web applications using React, TypeScript, Node, and .NET. I enjoy designing clean UI interactions, scalable backend APIs, and shipping features that users feel—not just infrastructure that runs. M.S. in Computer Science @ Northeastern (3.85 GPA), seeking full-time Full-Stack and Front-End roles.",
    "contact": {
      "email": "jondhalekar.k@northeastern.edu",
      "phone": "(857) 294-5334",
      "github": "https://github.com/KartikJondhalekar",
      "linkedin": "https://www.linkedin.com/in/kartik-jondhalekar/"
    }
  },
  "mindset": {
    "title": "How I Think",
    "sections": [
      {
        "id": "debugging",
        "title": "Debugging Complex Issues",
        "description": "I start with the hypothesis that breaks first—not the one I want to be true. I instrument, isolate, and reproduce before I theorize. Distributed systems fail in non-obvious ways, so I look at logs, traces, and metrics in parallel, not sequentially.",
        "approach": [
          "Reproduce the failure in isolation",
          "Identify the fault boundary (service, network, data layer)",
          "Check observability signals: logs, metrics, distributed traces",
          "Form testable hypotheses, validate with minimal changes",
          "Document findings for future engineers"
        ]
      },
      {
        "id": "tradeoffs",
        "title": "Evaluating Trade-offs",
        "description": "Every decision is a trade-off. Speed vs. correctness. Abstraction vs. simplicity. Build vs. buy. I evaluate trade-offs by asking: What's the cost of being wrong? What's the cost of changing course later? Can we test the assumption cheaply?",
        "approach": [
          "Define the constraint: time, reliability, cost, complexity",
          "Identify what you're optimizing for (and what you're not)",
          "Consider reversibility—can we undo this decision later?",
          "Bias toward simplicity unless complexity is justified",
          "Document the decision and revisit when context changes"
        ]
      },
      {
        "id": "unfamiliar",
        "title": "Approaching Unfamiliar Systems",
        "description": "I don't pretend to understand a system I've never touched. I start by reading the code, tracing request paths, and understanding failure modes. I ask: Where does data flow? What happens when things break? Who depends on this?",
        "approach": [
          "Read the README, then read the code",
          "Trace a request end-to-end (logs, metrics, code)",
          "Identify dependencies and failure points",
          "Run the system locally, break it intentionally",
          "Ask questions early, document learnings"
        ]
      },
      {
        "id": "speed-quality",
        "title": "Balancing Speed vs. Quality",
        "description": "Shipping fast matters. Shipping broken code matters more—but in the wrong direction. I bias toward incremental delivery: ship small, observable changes that can be rolled back. Quality isn't perfection; it's meeting the reliability bar for the use case.",
        "approach": [
          "Scope features into shippable increments",
          "Prioritize testability and observability over premature optimization",
          "Use feature flags for risky changes",
          "Define 'done' based on the reliability requirement, not ideal state",
          "Iterate based on production signals, not assumptions"
        ]
      }
    ]
  },
  "projects": [
    {
      "id": "ask-chinook",
      "title": "Ask Chinook",
      "subtitle": "Natural language to SQL system with safety-first AI execution",
      "technologies": [
        "TypeScript",
        "React",
        "Node.js",
        "Express",
        "OpenAI",
        "LangChain",
        "LangSmith"
      ],
      "domain": "AI · Developer Tools · Data Access",
      "category": "ai",
      "tier": 1,
      "visible": true,
      "github": "https://github.com/KartikJondhalekar/Ask-Chinook",
      "demo": null,
      "summary": "Built intuitive chat interface for natural language SQL queries with real-time results and enforced read-only execution. Demonstrates production-grade LLM safety patterns with clean UI.",
      "problem": "Non-technical users struggled to query relational databases safely and efficiently without SQL expertise.",
      "constraints": [
        "Strict read-only database access (no mutations)",
        "Preventing unsafe or destructive queries",
        "AI observability and reliability",
        "Low latency for interactive queries"
      ],
      "decisions": [
        {
          "decision": "Enforce SELECT-only execution at execution layer",
          "rationale": "Security by design, not by prompt engineering. Even if LLM generates DROP or UPDATE, execution layer blocks it."
        },
        {
          "decision": "Server-side API key handling",
          "rationale": "API keys never touch client. Reduces attack surface and prevents key leakage in browser dev tools."
        },
        {
          "decision": "Integrated LangSmith for observability",
          "rationale": "LLM failures are opaque. LangSmith provides latency metrics, token usage, and prompt/response pairs for debugging."
        },
        {
          "decision": "Used LangChain for prompt management",
          "rationale": "Keeps prompt logic modular and testable. Easier to iterate on prompt structure without redeploying."
        }
      ],
      "outcomes": [
        "Enabled safe self-service data access for non-technical users",
        "Improved query turnaround time by eliminating SQL writing bottleneck",
        "Demonstrated production-grade AI safety patterns",
        "Provided full observability into LLM behavior"
      ],
      "improvements": [
        "Add query result caching to reduce redundant LLM calls",
        "Implement feedback loop (user marks correct/incorrect results)",
        "Support multi-turn conversations for query refinement",
        "Add schema-aware context to improve query accuracy"
      ],
      "architecture": {
        "overview": "Three-tier architecture with validation layer between LLM and database execution.",
        "components": [
          "Frontend: React + TypeScript for query input and results",
          "API Layer: Express server handling LLM calls and SQL execution",
          "Validation Layer: Query parser blocking non-SELECT operations",
          "LangChain: Prompt construction and LLM orchestration",
          "LangSmith: Observability, tracing, and debugging"
        ],
        "dataFlow": "User query → API → LangChain → OpenAI → SQL generation → Validation → Execution → Results → Frontend"
      }
    },
    {
      "id": "f1-gpt",
      "title": "F1-GPT",
      "subtitle": "AI-powered Formula 1 knowledge system using Retrieval Augmented Generation",
      "technologies": [
        "TypeScript",
        "React",
        "OpenAI",
        "Vector DB",
        "RAG",
        "TailwindCSS"
      ],
      "domain": "AI · LLM · Full-Stack",
      "category": "ai",
      "tier": 1,
      "visible": true,
      "github": "https://github.com/KartikJondhalekar/F1-GPT",
      "demo": null,
      "summary": "Designed modern chat interface with real-time streaming responses and glassmorphism UI. Powered by RAG architecture to ground AI responses in factual F1 data.",
      "problem": "Static content and search-based systems failed to deliver real-time, context-aware Formula 1 insights.",
      "constraints": [
        "Low-latency responses for interactive chat",
        "High relevance and accuracy requirements",
        "Scalable AI architecture",
        "Preventing hallucinations on factual data"
      ],
      "decisions": [
        {
          "decision": "Implemented vector similarity search with embeddings",
          "rationale": "Converts racing data to embeddings, enabling semantic search. Retrieves most relevant context for each query."
        },
        {
          "decision": "Designed RAG pipelines for context injection",
          "rationale": "Grounds LLM responses in retrieved documents. Significantly reduces hallucinations compared to prompt-only approaches."
        },
        {
          "decision": "Real-time streaming AI responses",
          "rationale": "Improves perceived performance. Users see responses as they're generated rather than waiting for complete answers."
        },
        {
          "decision": "Modern UI with TailwindCSS",
          "rationale": "Responsive design with utility-first CSS. Fast development without custom CSS overhead."
        }
      ],
      "outcomes": [
        "Delivered accurate, context-aware responses on F1 history and statistics",
        "Reduced hallucinations compared to prompt-only LLMs",
        "Demonstrated scalable AI application design patterns",
        "Achieved sub-2s response times for most queries"
      ],
      "improvements": [
        "Add citation links to source documents",
        "Implement conversation memory for follow-up questions",
        "Cache embeddings for frequently accessed data",
        "Add feedback mechanism to improve retrieval quality"
      ],
      "architecture": {
        "overview": "RAG architecture combining vector search, LLM generation, and streaming responses.",
        "components": [
          "Vector Database: Stores F1 data as embeddings for semantic search",
          "Retrieval Layer: Finds relevant context via similarity search",
          "LLM Generation: OpenAI generates responses grounded in retrieved data",
          "Streaming API: Real-time token streaming to frontend",
          "Frontend: React + TailwindCSS with real-time UI updates"
        ],
        "dataFlow": "User query → Embedding → Vector search → Context retrieval → LLM prompt → Streaming response → Frontend"
      }
    },
    {
      "id": "kanbas-lms",
      "title": "Kanbas LMS",
      "subtitle": "Learning Management System inspired by Canvas",
      "technologies": [
        "React",
        "Node.js",
        "Express",
        "MongoDB"
      ],
      "domain": "Full-Stack · Web Applications",
      "category": "fullstack",
      "tier": 2,
      "visible": true,
      "github": [
        "https://github.com/KartikJondhalekar/kanbas-react-web-app",
        "https://github.com/KartikJondhalekar/kanbas-node-server-app"
      ],
      "demo": null,
      "summary": "Developed responsive, accessible dashboard UI for course management with reusable React components and API-driven navigation. Complete LMS feature set.",
      "problem": "Educational platforms require intuitive content management and role-based workflows for instructors and students.",
      "constraints": [
        "Complex entity relationships (courses, modules, assignments)",
        "Role-specific access (instructor vs. student permissions)",
        "Responsive UI requirements",
        "Real-time grade updates"
      ],
      "decisions": [
        {
          "decision": "Built RESTful APIs with Node.js + Express",
          "rationale": "Standard REST conventions. Easy to test and document. Supports frontend flexibility."
        },
        {
          "decision": "State-driven UI using React",
          "rationale": "Component-based architecture. Efficient re-rendering. Rich ecosystem for UI components."
        },
        {
          "decision": "MongoDB schema design for course data",
          "rationale": "Flexible schema for nested course structures. Document model matches domain objects naturally."
        },
        {
          "decision": "Implemented role-based interactions",
          "rationale": "Instructors create/edit content. Students view and submit. Enforced at both API and UI layers."
        }
      ],
      "outcomes": [
        "Delivered complete LMS feature set (courses, assignments, grades)",
        "Strengthened full-stack architectural skills",
        "Demonstrated end-to-end web application ownership",
        "Created scalable data model for educational content"
      ],
      "improvements": [
        "Add real-time notifications for grade updates",
        "Implement discussion forums",
        "Add file upload for assignment submissions",
        "Create analytics dashboard for instructors"
      ],
      "architecture": {
        "overview": "Classic MERN stack with RESTful API and React frontend.",
        "components": [
          "Frontend: React SPA with component-based architecture",
          "API: Node.js + Express RESTful services",
          "Database: MongoDB for flexible course data modeling",
          "Authentication: JWT-based user sessions",
          "Authorization: Role-based access control"
        ],
        "dataFlow": "React UI → REST API → Express Routes → MongoDB → Response → React State Update"
      }
    },
    {
      "id": "event-rsvp",
      "title": "Event RSVP Platform",
      "subtitle": "Fully serverless event management application on AWS",
      "technologies": [
        "HTML",
        "CSS",
        "JavaScript",
        "Node.js",
        "AWS Lambda",
        "API Gateway",
        "RDS",
        "DynamoDB",
        "S3",
        "CloudFront"
      ],
      "domain": "Cloud · Serverless · Full-Stack",
      "category": "cloud",
      "tier": 1,
      "visible": true,
      "github": "https://github.com/KartikJondhalekar/Event-RSVP-app",
      "demo": null,
      "summary": "Built serverless event platform with clean, responsive UI and AWS backend. Demonstrates cloud-native full-stack architecture ownership.",
      "problem": "Traditional server-based event systems were costly to scale and maintain for variable traffic patterns.",
      "constraints": [
        "Spiky traffic loads (event announcements)",
        "Minimal infrastructure management",
        "Secure public-facing APIs",
        "Cost-effective for low baseline traffic"
      ],
      "decisions": [
        {
          "decision": "API Gateway + Lambda for compute",
          "rationale": "Pay-per-request pricing. No idle costs. Automatic scaling for traffic spikes. Zero server management."
        },
        {
          "decision": "DynamoDB for RSVP data, RDS for event metadata",
          "rationale": "DynamoDB handles high-velocity RSVP writes. RDS provides relational structure for event data with complex queries."
        },
        {
          "decision": "S3 + CloudFront for frontend hosting",
          "rationale": "Static site hosting with global CDN. Sub-100ms latency worldwide. Minimal costs."
        },
        {
          "decision": "IAM-based access control",
          "rationale": "Leverage AWS-managed authentication. No custom auth code. Improved security posture."
        }
      ],
      "outcomes": [
        "Scaled automatically with demand, handling 500+ concurrent RSVPs",
        "Reduced operational overhead to near-zero",
        "Demonstrated cloud-native service ownership",
        "Sub-200ms API response times globally"
      ],
      "improvements": [
        "Add email notifications via SNS/SES",
        "Implement rate limiting for spam prevention",
        "Add analytics dashboard for organizers",
        "Support multi-event management"
      ],
      "architecture": {
        "overview": "Fully serverless architecture using AWS managed services. No EC2 instances or container orchestration.",
        "components": [
          "API Gateway: REST endpoints, request validation, throttling",
          "Lambda Functions: Business logic for RSVP operations",
          "DynamoDB: High-throughput RSVP data storage",
          "RDS: Event metadata with relational integrity",
          "S3 + CloudFront: Static hosting with global CDN"
        ],
        "dataFlow": "User → CloudFront → API Gateway → Lambda → DynamoDB/RDS → Response → CloudFront → User"
      }
    },
    {
      "id": "inventory-management",
      "title": "Inventory Management Tool",
      "subtitle": "Enterprise-grade platform modernized for scale, reliability, and cost efficiency",
      "technologies": [
        ".NET Framework",
        ".NET 6",
        "Angular 12",
        "Angular 15",
        "Entity Framework",
        "Azure SQL",
        "Azure"
      ],
      "domain": "Enterprise · Cloud · Backend",
      "category": "enterprise",
      "tier": 1,
      "visible": true,
      "github": null,
      "demo": null,
      "summary": "Modernized legacy inventory systems to cloud-native architecture, achieving zero-downtime migration while reducing costs by 25%.",
      "problem": "Legacy inventory systems struggled with scalability, deployment downtime, and rising infrastructure costs across enterprise operations.",
      "constraints": [
        "Zero-downtime migration requirements",
        "High concurrency enterprise usage",
        "Tight cost controls",
        "Backward compatibility with existing workflows"
      ],
      "decisions": [
        {
          "decision": "Designed ASP.NET Core APIs using layered architecture",
          "rationale": "Separated concerns (presentation, business, data) for maintainability. Enables independent testing and deployment of layers."
        },
        {
          "decision": "Implemented cloud-native deployment patterns on Azure",
          "rationale": "Azure App Service provides managed scaling, deployment slots for zero-downtime releases, and built-in monitoring."
        },
        {
          "decision": "Optimized data access with Azure SQL read replicas",
          "rationale": "Offloaded reporting queries from primary database, improving write performance and reducing contention."
        },
        {
          "decision": "Enabled phased migration with API versioning",
          "rationale": "Maintained backward compatibility while gradually migrating consumers. Reduced risk of breaking downstream systems."
        }
      ],
      "outcomes": [
        "Reduced infrastructure costs by 25% through right-sized cloud resources",
        "Improved system scalability and long-term maintainability",
        "Enabled safer releases with minimal operational disruption",
        "Zero downtime during entire 6-month migration"
      ],
      "improvements": [
        "Add distributed tracing for cross-service debugging",
        "Implement circuit breakers for external dependencies",
        "Migrate to event-driven architecture for real-time inventory updates",
        "Add predictive analytics for demand forecasting"
      ],
      "architecture": {
        "overview": "Migrated from monolithic .NET Framework on Windows VMs to modular .NET 6 services on Azure App Service.",
        "components": [
          "API Layer: ASP.NET Core REST APIs with JWT authentication",
          "Background Jobs: Scheduled inventory sync and validation",
          "Database: Azure SQL with read replicas for reporting workloads",
          "Frontend: Angular 15 SPA with Material Design",
          "CI/CD: Azure DevOps pipelines with automated testing"
        ],
        "dataFlow": "Angular SPA → Azure API Management → .NET 6 APIs → Azure SQL → Background Jobs → External Systems"
      }
    },
    {
      "id": "accrual-management",
      "title": "Accrual Management System",
      "subtitle": "Finance platform modernized to improve forecasting accuracy and operational visibility",
      "technologies": [
        ".NET Framework",
        "Angular 12",
        "MS SQL Server",
        "Azure Data Factory"
      ],
      "domain": "Enterprise · Finance · Data",
      "category": "enterprise",
      "tier": 1,
      "visible": true,
      "github": null,
      "demo": null,
      "summary": "Modernized finance workflows and integrated data pipelines, improving forecast accuracy by 35% for large-scale operations.",
      "problem": "Manual accrual workflows and legacy services limited forecast accuracy and financial visibility for large-scale operations.",
      "constraints": [
        "Regulatory and finance-grade accuracy requirements",
        "Legacy system dependencies",
        "Data consistency across reporting cycles",
        "No disruption to active financial periods"
      ],
      "decisions": [
        {
          "decision": "Refactored legacy services into modular APIs",
          "rationale": "Decomposed monolith into focused services for accrual calculation, approval workflows, and reporting. Improved testability and deployment independence."
        },
        {
          "decision": "Integrated Azure Data Factory for financial data processing",
          "rationale": "Automated data movement from source systems, applied transformations, and ensured timely availability for accrual calculations."
        },
        {
          "decision": "Improved data integrity with validation pipelines",
          "rationale": "Added pre-processing validation to catch data quality issues before they impacted financial calculations."
        },
        {
          "decision": "Enhanced calculation engine accuracy",
          "rationale": "Refined accrual algorithms and validation rules to improve forecast precision and reduce manual corrections."
        }
      ],
      "outcomes": [
        "Improved forecast accuracy by 35% through better data quality",
        "Increased transparency into accrual operations for finance teams",
        "Reduced manual intervention in finance workflows",
        "Enabled faster month-end close processes"
      ],
      "improvements": [
        "Add real-time accrual tracking dashboards",
        "Implement ML-based anomaly detection for unusual accruals",
        "Create audit trail for all calculation changes",
        "Add scenario modeling for forecast planning"
      ],
      "architecture": {
        "overview": "Modernized architecture combining .NET Framework services with Azure Data Factory for data orchestration.",
        "components": [
          "Calculation Engine: .NET Framework services for accrual logic",
          "Data Pipelines: Azure Data Factory for ETL workflows",
          "Workflow APIs: Approval and validation services",
          "Database: MS SQL Server with indexed views for reporting",
          "Frontend: Angular 12 for finance user interfaces"
        ],
        "dataFlow": "Source Systems → Azure Data Factory → SQL Server → .NET APIs → Angular UI → Finance Reports"
      }
    },
    {
      "id": "epayslip",
      "title": "ePayslip System",
      "subtitle": "Secure payroll platform optimized by removing legacy reporting dependencies",
      "technologies": [
        ".NET WebForms",
        ".NET 6",
        "Angular 15",
        "Azure",
        "MSAL",
        "Crystal Reports"
      ],
      "domain": "Enterprise · Security · Cost Optimization",
      "category": "enterprise",
      "tier": 2,
      "visible": true,
      "github": null,
      "demo": null,
      "summary": "Eliminated expensive legacy reporting tools while strengthening security, achieving measurable cost savings through cloud migration.",
      "problem": "Payroll reporting relied on expensive, tightly coupled legacy tools that increased operational cost and complexity.",
      "constraints": [
        "High data sensitivity (PII, payroll data)",
        "Enterprise authentication requirements",
        "Zero disruption to employees",
        "Maintaining regulatory compliance"
      ],
      "decisions": [
        {
          "decision": "Eliminated Crystal Reports dependency",
          "rationale": "Removed expensive licensing costs. Replaced with native .NET reporting capabilities."
        },
        {
          "decision": "Implemented MSAL-based SSO",
          "rationale": "Strengthened authentication with Azure AD. Removed custom credential management. Improved security posture."
        },
        {
          "decision": "Migrated from on-premise to Azure Cloud",
          "rationale": "Reduced infrastructure maintenance. Improved scalability and reliability. Enabled modern DevOps practices."
        },
        {
          "decision": "Modernized from WebForms to .NET 6 + Angular 15",
          "rationale": "Improved performance and maintainability. Modern SPA architecture with better user experience."
        }
      ],
      "outcomes": [
        "Achieved measurable cost savings from tooling removal and cloud migration",
        "Simplified payroll reporting architecture",
        "Improved security posture for HR systems",
        "Reduced maintenance burden on engineering team"
      ],
      "improvements": [
        "Add payslip download history tracking",
        "Implement multi-language support",
        "Add email delivery option for payslips",
        "Create mobile-optimized views"
      ],
      "architecture": {
        "overview": "Modernized payroll access with Azure-native authentication and simplified reporting.",
        "components": [
          "Authentication: MSAL + Azure AD for enterprise SSO",
          "API Layer: .NET 6 services with role-based access control",
          "Reporting: Native .NET PDF generation (no Crystal Reports)",
          "Frontend: Angular 15 SPA with responsive design",
          "Database: Azure SQL with encrypted PII data"
        ],
        "dataFlow": "Employee → MSAL SSO → Angular UI → .NET API → Azure SQL → PDF Generation → Secure Download"
      }
    },
    {
      "id": "data-quality",
      "title": "Data Quality Tool",
      "subtitle": "Enterprise platform for improving data integrity and compliance readiness",
      "technologies": [
        ".NET MVC",
        "MS SQL Server"
      ],
      "domain": "Enterprise · Compliance · Backend",
      "category": "enterprise",
      "tier": 2,
      "visible": true,
      "github": null,
      "demo": null,
      "summary": "Built validation workflows that reduced audit findings by 45% through improved data integrity monitoring.",
      "problem": "Inconsistent data quality across enterprise systems increased audit risk and manual reconciliation effort.",
      "constraints": [
        "Compliance-driven accuracy requirements",
        "Large datasets requiring efficient processing",
        "Audit traceability for all operations",
        "Role-based access to sensitive data"
      ],
      "decisions": [
        {
          "decision": "Developed .NET MVC services for data validation",
          "rationale": "Centralized validation logic. Reusable across multiple systems. Consistent rule enforcement."
        },
        {
          "decision": "Implemented role-based access control",
          "rationale": "Sensitive operations restricted to authorized users. Full audit trail of who changed what."
        },
        {
          "decision": "Designed audit-friendly workflows",
          "rationale": "Every validation result logged. Traceable from detection to resolution. Supports compliance reporting."
        },
        {
          "decision": "Optimized SQL queries for large datasets",
          "rationale": "Indexed frequently queried columns. Batch processing for bulk validations. Reduced processing time by 60%."
        }
      ],
      "outcomes": [
        "Reduced audit findings by 45% through proactive detection",
        "Improved trust in enterprise data pipelines",
        "Enabled faster issue detection and resolution",
        "Provided compliance-ready audit trails"
      ],
      "improvements": [
        "Add ML-based anomaly detection",
        "Implement real-time validation triggers",
        "Create data quality scorecards by system",
        "Add automated remediation for common issues"
      ],
      "architecture": {
        "overview": "Centralized validation platform with audit logging and role-based access.",
        "components": [
          "Validation Engine: .NET MVC services with configurable rules",
          "Database: MS SQL Server with optimized indexes",
          "Audit System: Comprehensive logging of all operations",
          "RBAC: Role-based access control for sensitive data",
          "Reporting: Compliance dashboards and audit exports"
        ],
        "dataFlow": "Source Systems → Validation Engine → SQL Server → Issue Detection → Workflow Assignment → Resolution → Audit Log"
      }
    }
  ],
  "additionalProjects": {
    "enterprise": [
      {
        "id": "phone-tracking",
        "title": "Phone Tracking System",
        "summary": "Asset management platform for tracking enterprise mobile devices across departments.",
        "technologies": [
          ".NET WebForms",
          "Azure"
        ],
        "category": "enterprise"
      },
      {
        "id": "vessel-performance",
        "title": "Vessel Performance System",
        "summary": "Maritime operations platform for monitoring vessel efficiency and fuel consumption.",
        "technologies": [
          "VB.NET",
          "Azure",
          "MS SQL Server"
        ],
        "category": "enterprise"
      },
      {
        "id": "partner-approval",
        "title": "Partner Approval System",
        "summary": "Workflow automation for partner vetting and approval processes.",
        "technologies": [
          ".NET MVC",
          "MS SQL Server"
        ],
        "category": "enterprise"
      },
      {
        "id": "overtime-approval",
        "title": "Overtime Pre-Approval System",
        "summary": "HR workflow tool for managing overtime requests and approvals.",
        "technologies": [
          ".NET Framework",
          "AngularJS",
          "MS SQL Server"
        ],
        "category": "enterprise"
      },
      {
        "id": "iems-exception",
        "title": "IEMS Exception Management",
        "summary": "Exception handling system for integrated energy management workflows.",
        "technologies": [
          ".NET WebForms",
          "Oracle DB"
        ],
        "category": "enterprise"
      },
      {
        "id": "home-loan",
        "title": "Hom-e-loan",
        "summary": "Home loan application processing and management system.",
        "technologies": [
          ".NET Core",
          "Angular 13",
          "SQL Server"
        ],
        "category": "enterprise"
      }
    ],
    "academic": [
      {
        "id": "cardbuddy",
        "title": "CardBuddy",
        "summary": "Android app for managing credit card benefits and rewards tracking.",
        "technologies": [
          "Android Studio",
          "Java",
          "Firebase"
        ],
        "category": "mobile"
      },
      {
        "id": "olympedia",
        "title": "Olympedia",
        "summary": "Database-driven Olympics statistics platform with complex query optimization.",
        "technologies": [
          "Python",
          "MySQL"
        ],
        "category": "data",
        "github": "https://github.com/KartikJondhalekar/Olympedia"
      },
      {
        "id": "open-library",
        "title": "Open Library Knowledge Miner",
        "summary": "ML-powered system for extracting insights from Open Library book metadata.",
        "technologies": [
          "Python",
          "Machine Learning"
        ],
        "category": "ai"
      }
    ]
  },
  "experience": [
    {
      "company": "LTIMindtree (Chevron)",
      "role": "Software Engineer",
      "period": "Jun 2021 – Aug 2023",
      "location": "Mumbai, India",
      "impact": [
        "Architected microservices supporting 150K+ users across regulated energy finance operations",
        "Reduced API processing latency by 35% through query optimization and layered architecture",
        "Improved release stability by 30% through containerization and observability practices",
        "Cut MTTR by 20% using structured logging and distributed tracing",
        "Reduced security audit findings by 45% via RBAC and MSAL SSO implementation"
      ]
    },
    {
      "company": "LTIMindtree",
      "role": "Graduate Engineer Trainee",
      "period": "Jan 2021 – Jun 2021",
      "location": "Mumbai, India",
      "impact": [
        "Resolved critical defects in .NET and SQL modules, improving functional correctness through rigorous peer reviews and regression testing",
        "Assisted with test execution and debugging across multiple enterprise systems, strengthening foundations in object-oriented programming and secure coding practices",
        "Collaborated with senior engineers on production support, gaining hands-on experience in enterprise software maintenance",
        "Participated in code reviews and design discussions, building knowledge in maintainable design patterns and software architecture"
      ]
    }
  ],
  "education": {
    "degree": "M.S. in Computer Science",
    "school": "Northeastern University",
    "location": "Boston, MA",
    "gpa": "3.85/4.0",
    "graduationDate": "Dec 2025",
    "status": "Completed"
  }
}